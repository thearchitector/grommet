{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Grommet \u00b6 High performance Python GraphQL server library Grommet is a GraphQL library for Python inspired by Strawberry and powered by async-graphql via Rust bindings. It combines Python's developer-friendly syntax with the performance of a native Rust GraphQL engine. Features \u00b6 High Performance - Powered by async-graphql through PyO3 Rust bindings Type Safe - Uses Python dataclasses and type annotations Async First - Built for async/await with full sync support Subscriptions - First-class support for GraphQL subscriptions Custom Scalars - Easy custom scalar type definitions Interfaces & Unions - Full support for abstract types Quick Example \u00b6 from dataclasses import dataclass import grommet as gm @gm . type @dataclass class Query : @gm . field @staticmethod async def hello ( parent , info , name : str = \"world\" ) -> str : return f \"Hello, { name } !\" schema = gm . Schema ( query = Query ) # Execute a query result = await schema . execute ( '{ hello(name: \"Ada\") }' ) print ( result [ \"data\" ][ \"hello\" ]) # Hello, Ada! Installation \u00b6 pip install grommet Or with uv : uv add grommet Why Grommet? \u00b6 Grommet bridges the gap between Python's ease of use and the performance demands of production GraphQL APIs. By leveraging Rust's async-graphql library through PyO3, Grommet achieves significant performance improvements over pure Python implementations while maintaining a familiar, Pythonic API. Next Steps \u00b6 Getting Started - Build your first GraphQL API Object Types - Learn about defining types Resolvers - Understand field resolution Subscriptions - Real-time data with subscriptions","title":"Home"},{"location":"#grommet","text":"High performance Python GraphQL server library Grommet is a GraphQL library for Python inspired by Strawberry and powered by async-graphql via Rust bindings. It combines Python's developer-friendly syntax with the performance of a native Rust GraphQL engine.","title":"Grommet"},{"location":"#features","text":"High Performance - Powered by async-graphql through PyO3 Rust bindings Type Safe - Uses Python dataclasses and type annotations Async First - Built for async/await with full sync support Subscriptions - First-class support for GraphQL subscriptions Custom Scalars - Easy custom scalar type definitions Interfaces & Unions - Full support for abstract types","title":"Features"},{"location":"#quick-example","text":"from dataclasses import dataclass import grommet as gm @gm . type @dataclass class Query : @gm . field @staticmethod async def hello ( parent , info , name : str = \"world\" ) -> str : return f \"Hello, { name } !\" schema = gm . Schema ( query = Query ) # Execute a query result = await schema . execute ( '{ hello(name: \"Ada\") }' ) print ( result [ \"data\" ][ \"hello\" ]) # Hello, Ada!","title":"Quick Example"},{"location":"#installation","text":"pip install grommet Or with uv : uv add grommet","title":"Installation"},{"location":"#why-grommet","text":"Grommet bridges the gap between Python's ease of use and the performance demands of production GraphQL APIs. By leveraging Rust's async-graphql library through PyO3, Grommet achieves significant performance improvements over pure Python implementations while maintaining a familiar, Pythonic API.","title":"Why Grommet?"},{"location":"#next-steps","text":"Getting Started - Build your first GraphQL API Object Types - Learn about defining types Resolvers - Understand field resolution Subscriptions - Real-time data with subscriptions","title":"Next Steps"},{"location":"api-reference/","text":"API Reference \u00b6 Complete reference for the Grommet public API. Schema \u00b6 gm.Schema \u00b6 The main schema class that compiles types and executes GraphQL operations. class Schema : def __init__ ( self , * , query : type , mutation : type | None = None , subscription : type | None = None , ) -> None : ... async def execute ( self , query : str , variables : dict [ str , Any ] | None = None , root : Any | None = None , context : Any | None = None , ) -> dict [ str , Any ]: ... def subscribe ( self , query : str , variables : dict [ str , Any ] | None = None , root : Any | None = None , context : Any | None = None , ) -> SubscriptionStream : ... def sdl ( self ) -> str : ... Parameters: query - The Query type (required) mutation - The Mutation type (optional) subscription - The Subscription type (optional) Methods: execute() - Execute a GraphQL query or mutation subscribe() - Create a subscription stream sdl() - Return the schema in SDL format Decorators \u00b6 @gm.type \u00b6 Marks a dataclass as a GraphQL object type. @gm . type ( name : str | None = None , description : str | None = None , implements : Iterable [ type ] | None = None , ) Parameters: name - Override the GraphQL type name description - Add documentation implements - List of interfaces to implement @gm.input \u00b6 Marks a dataclass as a GraphQL input type. @gm . input ( name : str | None = None , description : str | None = None , ) Parameters: name - Override the GraphQL type name description - Add documentation @gm.interface \u00b6 Marks a dataclass as a GraphQL interface. @gm . interface ( name : str | None = None , description : str | None = None , implements : Iterable [ type ] | None = None , ) Parameters: name - Override the GraphQL type name description - Add documentation implements - List of interfaces to extend @gm.field \u00b6 Declares a resolver-backed field on a GraphQL type. @gm . field ( name : str | None = None , description : str | None = None , deprecation_reason : str | None = None , default : Any = MISSING , default_factory : Callable [[], Any ] | None = MISSING , init : bool | None = None , ) Parameters: name - Override the GraphQL field name description - Add documentation deprecation_reason - Mark field as deprecated default - Default value for the dataclass field default_factory - Factory function for default value init - Include in dataclass __init__ @gm.scalar \u00b6 Registers a class as a GraphQL scalar type. @gm . scalar ( name : str | None = None , description : str | None = None , specified_by_url : str | None = None , serialize : Callable [[ Any ], Any ], parse_value : Callable [[ Any ], Any ], ) Parameters: name - Override the GraphQL scalar name description - Add documentation specified_by_url - Link to scalar specification serialize - Convert Python value to JSON output (required) parse_value - Convert JSON input to Python value (required) @gm.enum \u00b6 Registers an enum.Enum subclass as a GraphQL enum. @gm . enum ( name : str | None = None , description : str | None = None , ) Parameters: name - Override the GraphQL enum name description - Add documentation gm.union \u00b6 Creates a GraphQL union type. def union ( name : str , * , types : Iterable [ type ], description : str | None = None , ) -> type Parameters: name - The GraphQL union name (required) types - The possible types (required) description - Add documentation Types \u00b6 gm.ID \u00b6 GraphQL ID scalar type. Subclass of str . class ID ( str ): \"\"\"GraphQL ID scalar.\"\"\" Usage: @gm . type @dataclass class User : id : gm . ID gm.Internal \u00b6 Marks a field as internal (excluded from GraphQL schema). Internal [ T ] # Type alias Usage: @gm . type @dataclass class User : id : gm . ID password_hash : gm . Internal [ str ] # Not in GraphQL schema gm.Private \u00b6 Alias for Internal . Private [ T ] # Same as Internal[T] gm.Info \u00b6 Resolver metadata passed to every resolver. @dataclass ( frozen = True ) class Info : field_name : str context : Any | None = None root : Any | None = None Attributes: field_name - Name of the field being resolved context - Context passed to execute() or subscribe() root - Root value passed to execute() or subscribe() Functions \u00b6 gm.configure_runtime \u00b6 Configures the Tokio runtime for async execution. def configure_runtime ( * , use_current_thread : bool = False , worker_threads : int | None = None , ) -> bool Parameters: use_current_thread - Use single-threaded runtime worker_threads - Number of worker threads (multi-threaded only) Returns: True on success Raises: GrommetTypeError if use_current_thread=True and worker_threads is set Exceptions \u00b6 gm.GrommetError \u00b6 Base exception for all Grommet errors. class GrommetError ( Exception ): \"\"\"Base exception for grommet errors.\"\"\" gm.GrommetTypeError \u00b6 Raised for invalid types or annotations. class GrommetTypeError ( TypeError , GrommetError ): \"\"\"Raised when grommet encounters an invalid type or annotation.\"\"\" gm.GrommetValueError \u00b6 Raised for invalid values. class GrommetValueError ( ValueError , GrommetError ): \"\"\"Raised when grommet encounters an invalid value.\"\"\" gm.GrommetSchemaError \u00b6 Raised for invalid schema definitions. class GrommetSchemaError ( GrommetValueError ): \"\"\"Raised when the schema definition is invalid.\"\"\"","title":"API Reference"},{"location":"api-reference/#api-reference","text":"Complete reference for the Grommet public API.","title":"API Reference"},{"location":"api-reference/#schema","text":"","title":"Schema"},{"location":"api-reference/#gmschema","text":"The main schema class that compiles types and executes GraphQL operations. class Schema : def __init__ ( self , * , query : type , mutation : type | None = None , subscription : type | None = None , ) -> None : ... async def execute ( self , query : str , variables : dict [ str , Any ] | None = None , root : Any | None = None , context : Any | None = None , ) -> dict [ str , Any ]: ... def subscribe ( self , query : str , variables : dict [ str , Any ] | None = None , root : Any | None = None , context : Any | None = None , ) -> SubscriptionStream : ... def sdl ( self ) -> str : ... Parameters: query - The Query type (required) mutation - The Mutation type (optional) subscription - The Subscription type (optional) Methods: execute() - Execute a GraphQL query or mutation subscribe() - Create a subscription stream sdl() - Return the schema in SDL format","title":"gm.Schema"},{"location":"api-reference/#decorators","text":"","title":"Decorators"},{"location":"api-reference/#gmtype","text":"Marks a dataclass as a GraphQL object type. @gm . type ( name : str | None = None , description : str | None = None , implements : Iterable [ type ] | None = None , ) Parameters: name - Override the GraphQL type name description - Add documentation implements - List of interfaces to implement","title":"@gm.type"},{"location":"api-reference/#gminput","text":"Marks a dataclass as a GraphQL input type. @gm . input ( name : str | None = None , description : str | None = None , ) Parameters: name - Override the GraphQL type name description - Add documentation","title":"@gm.input"},{"location":"api-reference/#gminterface","text":"Marks a dataclass as a GraphQL interface. @gm . interface ( name : str | None = None , description : str | None = None , implements : Iterable [ type ] | None = None , ) Parameters: name - Override the GraphQL type name description - Add documentation implements - List of interfaces to extend","title":"@gm.interface"},{"location":"api-reference/#gmfield","text":"Declares a resolver-backed field on a GraphQL type. @gm . field ( name : str | None = None , description : str | None = None , deprecation_reason : str | None = None , default : Any = MISSING , default_factory : Callable [[], Any ] | None = MISSING , init : bool | None = None , ) Parameters: name - Override the GraphQL field name description - Add documentation deprecation_reason - Mark field as deprecated default - Default value for the dataclass field default_factory - Factory function for default value init - Include in dataclass __init__","title":"@gm.field"},{"location":"api-reference/#gmscalar","text":"Registers a class as a GraphQL scalar type. @gm . scalar ( name : str | None = None , description : str | None = None , specified_by_url : str | None = None , serialize : Callable [[ Any ], Any ], parse_value : Callable [[ Any ], Any ], ) Parameters: name - Override the GraphQL scalar name description - Add documentation specified_by_url - Link to scalar specification serialize - Convert Python value to JSON output (required) parse_value - Convert JSON input to Python value (required)","title":"@gm.scalar"},{"location":"api-reference/#gmenum","text":"Registers an enum.Enum subclass as a GraphQL enum. @gm . enum ( name : str | None = None , description : str | None = None , ) Parameters: name - Override the GraphQL enum name description - Add documentation","title":"@gm.enum"},{"location":"api-reference/#gmunion","text":"Creates a GraphQL union type. def union ( name : str , * , types : Iterable [ type ], description : str | None = None , ) -> type Parameters: name - The GraphQL union name (required) types - The possible types (required) description - Add documentation","title":"gm.union"},{"location":"api-reference/#types","text":"","title":"Types"},{"location":"api-reference/#gmid","text":"GraphQL ID scalar type. Subclass of str . class ID ( str ): \"\"\"GraphQL ID scalar.\"\"\" Usage: @gm . type @dataclass class User : id : gm . ID","title":"gm.ID"},{"location":"api-reference/#gminternal","text":"Marks a field as internal (excluded from GraphQL schema). Internal [ T ] # Type alias Usage: @gm . type @dataclass class User : id : gm . ID password_hash : gm . Internal [ str ] # Not in GraphQL schema","title":"gm.Internal"},{"location":"api-reference/#gmprivate","text":"Alias for Internal . Private [ T ] # Same as Internal[T]","title":"gm.Private"},{"location":"api-reference/#gminfo","text":"Resolver metadata passed to every resolver. @dataclass ( frozen = True ) class Info : field_name : str context : Any | None = None root : Any | None = None Attributes: field_name - Name of the field being resolved context - Context passed to execute() or subscribe() root - Root value passed to execute() or subscribe()","title":"gm.Info"},{"location":"api-reference/#functions","text":"","title":"Functions"},{"location":"api-reference/#gmconfigure_runtime","text":"Configures the Tokio runtime for async execution. def configure_runtime ( * , use_current_thread : bool = False , worker_threads : int | None = None , ) -> bool Parameters: use_current_thread - Use single-threaded runtime worker_threads - Number of worker threads (multi-threaded only) Returns: True on success Raises: GrommetTypeError if use_current_thread=True and worker_threads is set","title":"gm.configure_runtime"},{"location":"api-reference/#exceptions","text":"","title":"Exceptions"},{"location":"api-reference/#gmgrommeterror","text":"Base exception for all Grommet errors. class GrommetError ( Exception ): \"\"\"Base exception for grommet errors.\"\"\"","title":"gm.GrommetError"},{"location":"api-reference/#gmgrommettypeerror","text":"Raised for invalid types or annotations. class GrommetTypeError ( TypeError , GrommetError ): \"\"\"Raised when grommet encounters an invalid type or annotation.\"\"\"","title":"gm.GrommetTypeError"},{"location":"api-reference/#gmgrommetvalueerror","text":"Raised for invalid values. class GrommetValueError ( ValueError , GrommetError ): \"\"\"Raised when grommet encounters an invalid value.\"\"\"","title":"gm.GrommetValueError"},{"location":"api-reference/#gmgrommetschemaerror","text":"Raised for invalid schema definitions. class GrommetSchemaError ( GrommetValueError ): \"\"\"Raised when the schema definition is invalid.\"\"\"","title":"gm.GrommetSchemaError"},{"location":"getting-started/","text":"Getting Started \u00b6 This guide will walk you through creating your first GraphQL API with Grommet. Prerequisites \u00b6 Python 3.11 or later A Python package manager (pip, uv, poetry, etc.) Step 1: Install Grommet \u00b6 pip install grommet Or with uv: uv add grommet Step 2: Define Your First Type \u00b6 Create a file called schema.py : from dataclasses import dataclass import grommet as gm @gm . type @dataclass class Book : title : str author : str Every GraphQL type in Grommet is a Python dataclass decorated with @gm.type . The fields of the dataclass become fields in the GraphQL schema. Step 3: Create a Query Type \u00b6 The Query type is the entry point for all GraphQL queries: @gm . type @dataclass class Query : @gm . field @staticmethod async def books ( parent , info ) -> list [ Book ]: return [ Book ( title = \"The Great Gatsby\" , author = \"F. Scott Fitzgerald\" ), Book ( title = \"1984\" , author = \"George Orwell\" ), ] The @gm.field decorator marks a method as a resolver. Resolvers are functions that return data for a field. Step 4: Create the Schema \u00b6 schema = gm . Schema ( query = Query ) Step 5: Execute a Query \u00b6 import asyncio async def main (): result = await schema . execute ( \"\"\" { books { title author } } \"\"\" ) print ( result ) asyncio . run ( main ()) The result will be: { \"data\" : { \"books\" : [ { \"title\" : \"The Great Gatsby\" , \"author\" : \"F. Scott Fitzgerald\" }, { \"title\" : \"1984\" , \"author\" : \"George Orwell\" } ] } } Complete Example \u00b6 Here's the complete schema.py : import asyncio from dataclasses import dataclass import grommet as gm @gm . type @dataclass class Book : title : str author : str @gm . type @dataclass class Query : @gm . field @staticmethod async def books ( parent , info ) -> list [ Book ]: return [ Book ( title = \"The Great Gatsby\" , author = \"F. Scott Fitzgerald\" ), Book ( title = \"1984\" , author = \"George Orwell\" ), ] schema = gm . Schema ( query = Query ) async def main (): result = await schema . execute ( \"\"\" { books { title author } } \"\"\" ) print ( result ) if __name__ == \"__main__\" : asyncio . run ( main ()) Understanding Resolvers \u00b6 In the example above, books is a resolver. Every resolver receives two positional arguments: parent - The parent object (for root queries, this is typically None or a root value) info - A gm.Info object containing resolver metadata Additional arguments become GraphQL field arguments. Adding Arguments \u00b6 Let's add a search parameter: @gm . type @dataclass class Query : @gm . field @staticmethod async def books ( parent , info , search : str | None = None ) -> list [ Book ]: all_books = [ Book ( title = \"The Great Gatsby\" , author = \"F. Scott Fitzgerald\" ), Book ( title = \"1984\" , author = \"George Orwell\" ), ] if search : return [ b for b in all_books if search . lower () in b . title . lower ()] return all_books Now you can query with arguments: { books ( search : \"gatsby\" ) { title } } Next Steps \u00b6 Object Types - Learn more about defining types Input Types - Accept complex input arguments Subscriptions - Add real-time updates","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"This guide will walk you through creating your first GraphQL API with Grommet.","title":"Getting Started"},{"location":"getting-started/#prerequisites","text":"Python 3.11 or later A Python package manager (pip, uv, poetry, etc.)","title":"Prerequisites"},{"location":"getting-started/#step-1-install-grommet","text":"pip install grommet Or with uv: uv add grommet","title":"Step 1: Install Grommet"},{"location":"getting-started/#step-2-define-your-first-type","text":"Create a file called schema.py : from dataclasses import dataclass import grommet as gm @gm . type @dataclass class Book : title : str author : str Every GraphQL type in Grommet is a Python dataclass decorated with @gm.type . The fields of the dataclass become fields in the GraphQL schema.","title":"Step 2: Define Your First Type"},{"location":"getting-started/#step-3-create-a-query-type","text":"The Query type is the entry point for all GraphQL queries: @gm . type @dataclass class Query : @gm . field @staticmethod async def books ( parent , info ) -> list [ Book ]: return [ Book ( title = \"The Great Gatsby\" , author = \"F. Scott Fitzgerald\" ), Book ( title = \"1984\" , author = \"George Orwell\" ), ] The @gm.field decorator marks a method as a resolver. Resolvers are functions that return data for a field.","title":"Step 3: Create a Query Type"},{"location":"getting-started/#step-4-create-the-schema","text":"schema = gm . Schema ( query = Query )","title":"Step 4: Create the Schema"},{"location":"getting-started/#step-5-execute-a-query","text":"import asyncio async def main (): result = await schema . execute ( \"\"\" { books { title author } } \"\"\" ) print ( result ) asyncio . run ( main ()) The result will be: { \"data\" : { \"books\" : [ { \"title\" : \"The Great Gatsby\" , \"author\" : \"F. Scott Fitzgerald\" }, { \"title\" : \"1984\" , \"author\" : \"George Orwell\" } ] } }","title":"Step 5: Execute a Query"},{"location":"getting-started/#complete-example","text":"Here's the complete schema.py : import asyncio from dataclasses import dataclass import grommet as gm @gm . type @dataclass class Book : title : str author : str @gm . type @dataclass class Query : @gm . field @staticmethod async def books ( parent , info ) -> list [ Book ]: return [ Book ( title = \"The Great Gatsby\" , author = \"F. Scott Fitzgerald\" ), Book ( title = \"1984\" , author = \"George Orwell\" ), ] schema = gm . Schema ( query = Query ) async def main (): result = await schema . execute ( \"\"\" { books { title author } } \"\"\" ) print ( result ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Complete Example"},{"location":"getting-started/#understanding-resolvers","text":"In the example above, books is a resolver. Every resolver receives two positional arguments: parent - The parent object (for root queries, this is typically None or a root value) info - A gm.Info object containing resolver metadata Additional arguments become GraphQL field arguments.","title":"Understanding Resolvers"},{"location":"getting-started/#adding-arguments","text":"Let's add a search parameter: @gm . type @dataclass class Query : @gm . field @staticmethod async def books ( parent , info , search : str | None = None ) -> list [ Book ]: all_books = [ Book ( title = \"The Great Gatsby\" , author = \"F. Scott Fitzgerald\" ), Book ( title = \"1984\" , author = \"George Orwell\" ), ] if search : return [ b for b in all_books if search . lower () in b . title . lower ()] return all_books Now you can query with arguments: { books ( search : \"gatsby\" ) { title } }","title":"Adding Arguments"},{"location":"getting-started/#next-steps","text":"Object Types - Learn more about defining types Input Types - Accept complex input arguments Subscriptions - Add real-time updates","title":"Next Steps"},{"location":"resolvers/","text":"Resolvers \u00b6 Resolvers are functions that return data for GraphQL fields. They're the bridge between your GraphQL schema and your data sources. Basic Resolvers \u00b6 Use the @gm.field decorator to define a resolver: from dataclasses import dataclass import grommet as gm @gm . type @dataclass class Query : @gm . field @staticmethod async def hello ( parent , info ) -> str : return \"Hello, world!\" Resolver Arguments \u00b6 Required Arguments \u00b6 Every resolver receives two positional arguments: parent - The parent object. For root queries, this is the root value (or None ) info - A gm.Info object containing resolver metadata @gm . field @staticmethod async def greeting ( parent , info ) -> str : print ( f \"Resolving field: { info . field_name } \" ) return \"Hello!\" The Info Object \u00b6 gm.Info provides metadata about the current resolution: @dataclass ( frozen = True ) class Info : field_name : str # Name of the field being resolved context : Any | None # Context passed to execute/subscribe root : Any | None # Root value passed to execute/subscribe Field Arguments \u00b6 Additional resolver parameters become GraphQL field arguments: @gm . field @staticmethod async def greet ( parent , info , name : str ) -> str : return f \"Hello, { name } !\" { greet ( name : \"Alice\" ) # Returns \"Hello, Alice!\" } Default Values \u00b6 Parameters with defaults become optional arguments: @gm . field @staticmethod async def greet ( parent , info , name : str = \"world\" ) -> str : return f \"Hello, { name } !\" { greet # Returns \"Hello, world!\" greet ( name : \"Bob\" ) # Returns \"Hello, Bob!\" } Resolver Styles \u00b6 Static Methods (Recommended) \u00b6 @gm . type @dataclass class Query : @gm . field @staticmethod async def users ( parent , info ) -> list [ User ]: return await fetch_users () Class Methods \u00b6 @gm . type @dataclass class Query : @gm . field @classmethod async def users ( cls , parent , info ) -> list [ User ]: return await fetch_users () Instance Methods \u00b6 For fields that depend on instance data: @gm . type @dataclass class User : id : gm . ID first_name : str last_name : str @gm . field async def full_name ( self , parent , info ) -> str : return f \" { self . first_name } { self . last_name } \" Note For instance methods, self is the instance and parent is the parent object from GraphQL resolution (often the same as self ). Async vs Sync Resolvers \u00b6 Async Resolvers (Recommended) \u00b6 @gm . field @staticmethod async def users ( parent , info ) -> list [ User ]: return await database . fetch_users () Sync Resolvers \u00b6 Sync resolvers are also supported: @gm . field @staticmethod def version ( parent , info ) -> str : return \"1.0.0\" Field Parameters \u00b6 The @gm.field decorator accepts several parameters: name \u00b6 Override the GraphQL field name: @gm . field ( name = \"userName\" ) @staticmethod async def get_user_name ( parent , info ) -> str : return \"Alice\" description \u00b6 Add field documentation: @gm . field ( description = \"Returns the current user's name\" ) @staticmethod async def name ( parent , info ) -> str : return \"Alice\" deprecation_reason \u00b6 Mark a field as deprecated: @gm . field ( deprecation_reason = \"Use 'fullName' instead\" ) @staticmethod async def name ( parent , info ) -> str : return \"Alice\" default / default_factory \u00b6 Provide default values for the dataclass field: @gm . type @dataclass class User : id : gm . ID @gm . field ( default = \"Anonymous\" ) @staticmethod async def display_name ( parent , info ) -> str : return parent . name if hasattr ( parent , \"name\" ) else \"Anonymous\" Accessing Context \u00b6 Pass context when executing queries: result = await schema . execute ( \"{ currentUser { name } }\" , context = { \"user_id\" : \"123\" , \"db\" : database }, ) Access it in resolvers via info.context : @gm . field @staticmethod async def current_user ( parent , info ) -> User : user_id = info . context [ \"user_id\" ] db = info . context [ \"db\" ] return await db . get_user ( user_id ) Accessing Root Value \u00b6 Pass a root value when executing: result = await schema . execute ( \"{ greeting }\" , root = { \"message\" : \"Hello from root!\" }, ) Access it via info.root or parent (for root-level fields): @gm . field @staticmethod async def greeting ( parent , info ) -> str : return parent [ \"message\" ] # or info.root[\"message\"] Fields Without Resolvers \u00b6 Fields without @gm.field are resolved from the parent object: @gm . type @dataclass class User : id : gm . ID name : str # Resolved from User instance email : str # Resolved from User instance Complex Arguments \u00b6 Input Types \u00b6 Use input types for complex arguments: @gm . input @dataclass class CreateUserInput : name : str email : str @gm . field @staticmethod async def create_user ( parent , info , input : CreateUserInput ) -> User : return User ( id = gm . ID ( \"1\" ), name = input . name , email = input . email ) Lists \u00b6 @gm . field @staticmethod async def users_by_ids ( parent , info , ids : list [ gm . ID ]) -> list [ User ]: return await fetch_users_by_ids ( ids ) Enums \u00b6 @gm . field @staticmethod async def users_by_status ( parent , info , status : Status ) -> list [ User ]: return await fetch_users_by_status ( status ) Error Handling \u00b6 Raise exceptions to return GraphQL errors: @gm . field @staticmethod async def user ( parent , info , id : gm . ID ) -> User : user = await fetch_user ( id ) if user is None : raise ValueError ( f \"User { id } not found\" ) return user The error appears in the response: { \"data\" : { \"user\" : null }, \"errors\" : [ { \"message\" : \"User 123 not found\" , \"path\" : [ \"user\" ] } ] }","title":"Resolvers"},{"location":"resolvers/#resolvers","text":"Resolvers are functions that return data for GraphQL fields. They're the bridge between your GraphQL schema and your data sources.","title":"Resolvers"},{"location":"resolvers/#basic-resolvers","text":"Use the @gm.field decorator to define a resolver: from dataclasses import dataclass import grommet as gm @gm . type @dataclass class Query : @gm . field @staticmethod async def hello ( parent , info ) -> str : return \"Hello, world!\"","title":"Basic Resolvers"},{"location":"resolvers/#resolver-arguments","text":"","title":"Resolver Arguments"},{"location":"resolvers/#required-arguments","text":"Every resolver receives two positional arguments: parent - The parent object. For root queries, this is the root value (or None ) info - A gm.Info object containing resolver metadata @gm . field @staticmethod async def greeting ( parent , info ) -> str : print ( f \"Resolving field: { info . field_name } \" ) return \"Hello!\"","title":"Required Arguments"},{"location":"resolvers/#the-info-object","text":"gm.Info provides metadata about the current resolution: @dataclass ( frozen = True ) class Info : field_name : str # Name of the field being resolved context : Any | None # Context passed to execute/subscribe root : Any | None # Root value passed to execute/subscribe","title":"The Info Object"},{"location":"resolvers/#field-arguments","text":"Additional resolver parameters become GraphQL field arguments: @gm . field @staticmethod async def greet ( parent , info , name : str ) -> str : return f \"Hello, { name } !\" { greet ( name : \"Alice\" ) # Returns \"Hello, Alice!\" }","title":"Field Arguments"},{"location":"resolvers/#default-values","text":"Parameters with defaults become optional arguments: @gm . field @staticmethod async def greet ( parent , info , name : str = \"world\" ) -> str : return f \"Hello, { name } !\" { greet # Returns \"Hello, world!\" greet ( name : \"Bob\" ) # Returns \"Hello, Bob!\" }","title":"Default Values"},{"location":"resolvers/#resolver-styles","text":"","title":"Resolver Styles"},{"location":"resolvers/#static-methods-recommended","text":"@gm . type @dataclass class Query : @gm . field @staticmethod async def users ( parent , info ) -> list [ User ]: return await fetch_users ()","title":"Static Methods (Recommended)"},{"location":"resolvers/#class-methods","text":"@gm . type @dataclass class Query : @gm . field @classmethod async def users ( cls , parent , info ) -> list [ User ]: return await fetch_users ()","title":"Class Methods"},{"location":"resolvers/#instance-methods","text":"For fields that depend on instance data: @gm . type @dataclass class User : id : gm . ID first_name : str last_name : str @gm . field async def full_name ( self , parent , info ) -> str : return f \" { self . first_name } { self . last_name } \" Note For instance methods, self is the instance and parent is the parent object from GraphQL resolution (often the same as self ).","title":"Instance Methods"},{"location":"resolvers/#async-vs-sync-resolvers","text":"","title":"Async vs Sync Resolvers"},{"location":"resolvers/#async-resolvers-recommended","text":"@gm . field @staticmethod async def users ( parent , info ) -> list [ User ]: return await database . fetch_users ()","title":"Async Resolvers (Recommended)"},{"location":"resolvers/#sync-resolvers","text":"Sync resolvers are also supported: @gm . field @staticmethod def version ( parent , info ) -> str : return \"1.0.0\"","title":"Sync Resolvers"},{"location":"resolvers/#field-parameters","text":"The @gm.field decorator accepts several parameters:","title":"Field Parameters"},{"location":"resolvers/#name","text":"Override the GraphQL field name: @gm . field ( name = \"userName\" ) @staticmethod async def get_user_name ( parent , info ) -> str : return \"Alice\"","title":"name"},{"location":"resolvers/#description","text":"Add field documentation: @gm . field ( description = \"Returns the current user's name\" ) @staticmethod async def name ( parent , info ) -> str : return \"Alice\"","title":"description"},{"location":"resolvers/#deprecation_reason","text":"Mark a field as deprecated: @gm . field ( deprecation_reason = \"Use 'fullName' instead\" ) @staticmethod async def name ( parent , info ) -> str : return \"Alice\"","title":"deprecation_reason"},{"location":"resolvers/#default-default_factory","text":"Provide default values for the dataclass field: @gm . type @dataclass class User : id : gm . ID @gm . field ( default = \"Anonymous\" ) @staticmethod async def display_name ( parent , info ) -> str : return parent . name if hasattr ( parent , \"name\" ) else \"Anonymous\"","title":"default / default_factory"},{"location":"resolvers/#accessing-context","text":"Pass context when executing queries: result = await schema . execute ( \"{ currentUser { name } }\" , context = { \"user_id\" : \"123\" , \"db\" : database }, ) Access it in resolvers via info.context : @gm . field @staticmethod async def current_user ( parent , info ) -> User : user_id = info . context [ \"user_id\" ] db = info . context [ \"db\" ] return await db . get_user ( user_id )","title":"Accessing Context"},{"location":"resolvers/#accessing-root-value","text":"Pass a root value when executing: result = await schema . execute ( \"{ greeting }\" , root = { \"message\" : \"Hello from root!\" }, ) Access it via info.root or parent (for root-level fields): @gm . field @staticmethod async def greeting ( parent , info ) -> str : return parent [ \"message\" ] # or info.root[\"message\"]","title":"Accessing Root Value"},{"location":"resolvers/#fields-without-resolvers","text":"Fields without @gm.field are resolved from the parent object: @gm . type @dataclass class User : id : gm . ID name : str # Resolved from User instance email : str # Resolved from User instance","title":"Fields Without Resolvers"},{"location":"resolvers/#complex-arguments","text":"","title":"Complex Arguments"},{"location":"resolvers/#input-types","text":"Use input types for complex arguments: @gm . input @dataclass class CreateUserInput : name : str email : str @gm . field @staticmethod async def create_user ( parent , info , input : CreateUserInput ) -> User : return User ( id = gm . ID ( \"1\" ), name = input . name , email = input . email )","title":"Input Types"},{"location":"resolvers/#lists","text":"@gm . field @staticmethod async def users_by_ids ( parent , info , ids : list [ gm . ID ]) -> list [ User ]: return await fetch_users_by_ids ( ids )","title":"Lists"},{"location":"resolvers/#enums","text":"@gm . field @staticmethod async def users_by_status ( parent , info , status : Status ) -> list [ User ]: return await fetch_users_by_status ( status )","title":"Enums"},{"location":"resolvers/#error-handling","text":"Raise exceptions to return GraphQL errors: @gm . field @staticmethod async def user ( parent , info , id : gm . ID ) -> User : user = await fetch_user ( id ) if user is None : raise ValueError ( f \"User { id } not found\" ) return user The error appears in the response: { \"data\" : { \"user\" : null }, \"errors\" : [ { \"message\" : \"User 123 not found\" , \"path\" : [ \"user\" ] } ] }","title":"Error Handling"},{"location":"runtime/","text":"Runtime Configuration \u00b6 Grommet uses a Tokio runtime for async execution. You can configure this runtime before creating schemas. Default Runtime \u00b6 By default, Grommet uses a multi-threaded Tokio runtime. This is suitable for most applications. Configuring the Runtime \u00b6 Use gm.configure_runtime() to customize the runtime: import grommet as gm # Configure before creating any schemas gm . configure_runtime ( use_current_thread = True ) # Now create your schema schema = gm . Schema ( query = Query ) Warning configure_runtime() must be called before creating any Schema instances. Calling it after schema creation has no effect. Options \u00b6 use_current_thread \u00b6 Run the Tokio runtime on the current thread instead of spawning worker threads: gm . configure_runtime ( use_current_thread = True ) This is useful for: Single-threaded environments Debugging Reducing resource usage in simple applications worker_threads \u00b6 Set the number of worker threads for the multi-threaded runtime: gm . configure_runtime ( worker_threads = 4 ) Note worker_threads cannot be used with use_current_thread=True . This combination raises an error. Examples \u00b6 Single-Threaded Runtime \u00b6 import grommet as gm gm . configure_runtime ( use_current_thread = True ) Custom Thread Count \u00b6 import grommet as gm # Use 8 worker threads gm . configure_runtime ( worker_threads = 8 ) Default Multi-Threaded Runtime \u00b6 import grommet as gm # Explicitly use defaults (multi-threaded with auto thread count) gm . configure_runtime () When to Configure \u00b6 Configure the runtime at application startup, before any GraphQL operations: # app.py import grommet as gm from myapp.schema import Query # Configure runtime first gm . configure_runtime ( worker_threads = 4 ) # Then create schema schema = gm . Schema ( query = Query ) Integration with Web Frameworks \u00b6 FastAPI \u00b6 from contextlib import asynccontextmanager import grommet as gm from fastapi import FastAPI @asynccontextmanager async def lifespan ( app : FastAPI ): # Configure runtime at startup gm . configure_runtime ( worker_threads = 4 ) yield app = FastAPI ( lifespan = lifespan ) Starlette \u00b6 import grommet as gm from starlette.applications import Starlette # Configure at module load gm . configure_runtime ( worker_threads = 4 ) app = Starlette () Return Value \u00b6 configure_runtime() returns True on success: success = gm . configure_runtime ( use_current_thread = True ) assert success is True Errors \u00b6 Invalid Configuration \u00b6 # Raises GrommetTypeError gm . configure_runtime ( use_current_thread = True , worker_threads = 4 ) # Error: worker_threads cannot be set for a current-thread runtime Performance Considerations \u00b6 Multi-threaded (default) : Best for production with concurrent requests Current-thread : Lower overhead, suitable for testing or single-request scenarios Custom thread count : Tune based on your workload and available cores","title":"Runtime"},{"location":"runtime/#runtime-configuration","text":"Grommet uses a Tokio runtime for async execution. You can configure this runtime before creating schemas.","title":"Runtime Configuration"},{"location":"runtime/#default-runtime","text":"By default, Grommet uses a multi-threaded Tokio runtime. This is suitable for most applications.","title":"Default Runtime"},{"location":"runtime/#configuring-the-runtime","text":"Use gm.configure_runtime() to customize the runtime: import grommet as gm # Configure before creating any schemas gm . configure_runtime ( use_current_thread = True ) # Now create your schema schema = gm . Schema ( query = Query ) Warning configure_runtime() must be called before creating any Schema instances. Calling it after schema creation has no effect.","title":"Configuring the Runtime"},{"location":"runtime/#options","text":"","title":"Options"},{"location":"runtime/#use_current_thread","text":"Run the Tokio runtime on the current thread instead of spawning worker threads: gm . configure_runtime ( use_current_thread = True ) This is useful for: Single-threaded environments Debugging Reducing resource usage in simple applications","title":"use_current_thread"},{"location":"runtime/#worker_threads","text":"Set the number of worker threads for the multi-threaded runtime: gm . configure_runtime ( worker_threads = 4 ) Note worker_threads cannot be used with use_current_thread=True . This combination raises an error.","title":"worker_threads"},{"location":"runtime/#examples","text":"","title":"Examples"},{"location":"runtime/#single-threaded-runtime","text":"import grommet as gm gm . configure_runtime ( use_current_thread = True )","title":"Single-Threaded Runtime"},{"location":"runtime/#custom-thread-count","text":"import grommet as gm # Use 8 worker threads gm . configure_runtime ( worker_threads = 8 )","title":"Custom Thread Count"},{"location":"runtime/#default-multi-threaded-runtime","text":"import grommet as gm # Explicitly use defaults (multi-threaded with auto thread count) gm . configure_runtime ()","title":"Default Multi-Threaded Runtime"},{"location":"runtime/#when-to-configure","text":"Configure the runtime at application startup, before any GraphQL operations: # app.py import grommet as gm from myapp.schema import Query # Configure runtime first gm . configure_runtime ( worker_threads = 4 ) # Then create schema schema = gm . Schema ( query = Query )","title":"When to Configure"},{"location":"runtime/#integration-with-web-frameworks","text":"","title":"Integration with Web Frameworks"},{"location":"runtime/#fastapi","text":"from contextlib import asynccontextmanager import grommet as gm from fastapi import FastAPI @asynccontextmanager async def lifespan ( app : FastAPI ): # Configure runtime at startup gm . configure_runtime ( worker_threads = 4 ) yield app = FastAPI ( lifespan = lifespan )","title":"FastAPI"},{"location":"runtime/#starlette","text":"import grommet as gm from starlette.applications import Starlette # Configure at module load gm . configure_runtime ( worker_threads = 4 ) app = Starlette ()","title":"Starlette"},{"location":"runtime/#return-value","text":"configure_runtime() returns True on success: success = gm . configure_runtime ( use_current_thread = True ) assert success is True","title":"Return Value"},{"location":"runtime/#errors","text":"","title":"Errors"},{"location":"runtime/#invalid-configuration","text":"# Raises GrommetTypeError gm . configure_runtime ( use_current_thread = True , worker_threads = 4 ) # Error: worker_threads cannot be set for a current-thread runtime","title":"Invalid Configuration"},{"location":"runtime/#performance-considerations","text":"Multi-threaded (default) : Best for production with concurrent requests Current-thread : Lower overhead, suitable for testing or single-request scenarios Custom thread count : Tune based on your workload and available cores","title":"Performance Considerations"},{"location":"schema/","text":"Schema \u00b6 The Schema class is the core of Grommet. It compiles your type definitions into a GraphQL schema and provides methods for executing queries and subscriptions. Creating a Schema \u00b6 import grommet as gm schema = gm . Schema ( query = Query ) With Mutations \u00b6 schema = gm . Schema ( query = Query , mutation = Mutation , ) With Subscriptions \u00b6 schema = gm . Schema ( query = Query , mutation = Mutation , subscription = Subscription , ) Executing Queries \u00b6 Use execute() to run GraphQL queries: result = await schema . execute ( \"{ hello }\" ) With Variables \u00b6 result = await schema . execute ( \"\"\" query ($name: String!) { greet(name: $name) } \"\"\" , variables = { \"name\" : \"Alice\" }, ) With Context \u00b6 Pass request-specific data to resolvers: result = await schema . execute ( \"{ currentUser { name } }\" , context = { \"user_id\" : \"123\" , \"request\" : request , \"db\" : database , }, ) With Root Value \u00b6 Provide a root object for top-level resolvers: result = await schema . execute ( \"{ config }\" , root = { \"config\" : app_config }, ) Response Format \u00b6 Execution returns a dictionary with the standard GraphQL response format: { \"data\" : { \"hello\" : \"Hello, world!\" } } With Errors \u00b6 { \"data\" : { \"user\" : None }, \"errors\" : [ { \"message\" : \"User not found\" , \"path\" : [ \"user\" ], \"locations\" : [{ \"line\" : 1 , \"column\" : 3 }] } ] } Partial Results \u00b6 GraphQL can return partial data with errors: { \"data\" : { \"users\" : [ { \"name\" : \"Alice\" }, None , # This user's resolver failed { \"name\" : \"Charlie\" } ] }, \"errors\" : [ { \"message\" : \"Failed to fetch user\" , \"path\" : [ \"users\" , 1 ]} ] } Subscriptions \u00b6 Use subscribe() for real-time data: stream = schema . subscribe ( \"subscription { messages { text } }\" ) async for payload in stream : print ( payload [ \"data\" ][ \"messages\" ][ \"text\" ]) See Subscriptions for details. Schema Introspection \u00b6 SDL Output \u00b6 Get the GraphQL Schema Definition Language: print ( schema . sdl ()) Output: type Query { hello : String ! users : [ User !]! } type User { id : ID ! name : String ! email : String ! } Type Discovery \u00b6 Grommet automatically discovers types referenced by your schema: @gm . type @dataclass class User : id : gm . ID name : str posts : list [ \"Post\" ] @gm . type @dataclass class Post : id : gm . ID title : str author : User @gm . type @dataclass class Query : @gm . field @staticmethod async def user ( parent , info , id : gm . ID ) -> User : ... # Both User and Post are included in the schema schema = gm . Schema ( query = Query ) Schema Requirements \u00b6 Query Type Required \u00b6 Every schema must have a query type: # \u2705 Valid schema = gm . Schema ( query = Query ) # \u274c Invalid - raises GrommetSchemaError schema = gm . Schema ( query = None ) Types Must Be Decorated \u00b6 All types used in the schema must be decorated: # \u2705 Valid - User is decorated @gm . type @dataclass class User : name : str # \u274c Invalid - PlainClass is not decorated @dataclass class PlainClass : name : str Complete Example \u00b6 import asyncio from dataclasses import dataclass from typing import TYPE_CHECKING import grommet as gm if TYPE_CHECKING : from collections.abc import AsyncIterator @gm . type @dataclass class User : id : gm . ID name : str email : str @gm . type @dataclass class Query : @gm . field @staticmethod async def user ( parent , info , id : gm . ID ) -> User | None : users = { \"1\" : User ( id = gm . ID ( \"1\" ), name = \"Alice\" , email = \"alice@example.com\" )} return users . get ( str ( id )) @gm . field @staticmethod async def users ( parent , info ) -> list [ User ]: return [ User ( id = gm . ID ( \"1\" ), name = \"Alice\" , email = \"alice@example.com\" ), User ( id = gm . ID ( \"2\" ), name = \"Bob\" , email = \"bob@example.com\" ), ] @gm . input @dataclass class CreateUserInput : name : str email : str @gm . type @dataclass class Mutation : @gm . field @staticmethod async def create_user ( parent , info , input : CreateUserInput ) -> User : return User ( id = gm . ID ( \"3\" ), name = input . name , email = input . email , ) @gm . type @dataclass class Subscription : @gm . field @staticmethod async def countdown ( parent , info , start : int ) -> \"AsyncIterator[int]\" : for i in range ( start , 0 , - 1 ): yield i await asyncio . sleep ( 1 ) schema = gm . Schema ( query = Query , mutation = Mutation , subscription = Subscription , ) async def main (): # Query result = await schema . execute ( '{ user(id: \"1\") { name } }' ) print ( result ) # Mutation result = await schema . execute ( ''' mutation { createUser(input: { name: \"Charlie\", email: \"charlie@example.com\" }) { id name } } ''' ) print ( result ) # Subscription stream = schema . subscribe ( \"subscription { countdown(start: 3) }\" ) async for payload in stream : print ( payload ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Schema"},{"location":"schema/#schema","text":"The Schema class is the core of Grommet. It compiles your type definitions into a GraphQL schema and provides methods for executing queries and subscriptions.","title":"Schema"},{"location":"schema/#creating-a-schema","text":"import grommet as gm schema = gm . Schema ( query = Query )","title":"Creating a Schema"},{"location":"schema/#with-mutations","text":"schema = gm . Schema ( query = Query , mutation = Mutation , )","title":"With Mutations"},{"location":"schema/#with-subscriptions","text":"schema = gm . Schema ( query = Query , mutation = Mutation , subscription = Subscription , )","title":"With Subscriptions"},{"location":"schema/#executing-queries","text":"Use execute() to run GraphQL queries: result = await schema . execute ( \"{ hello }\" )","title":"Executing Queries"},{"location":"schema/#with-variables","text":"result = await schema . execute ( \"\"\" query ($name: String!) { greet(name: $name) } \"\"\" , variables = { \"name\" : \"Alice\" }, )","title":"With Variables"},{"location":"schema/#with-context","text":"Pass request-specific data to resolvers: result = await schema . execute ( \"{ currentUser { name } }\" , context = { \"user_id\" : \"123\" , \"request\" : request , \"db\" : database , }, )","title":"With Context"},{"location":"schema/#with-root-value","text":"Provide a root object for top-level resolvers: result = await schema . execute ( \"{ config }\" , root = { \"config\" : app_config }, )","title":"With Root Value"},{"location":"schema/#response-format","text":"Execution returns a dictionary with the standard GraphQL response format: { \"data\" : { \"hello\" : \"Hello, world!\" } }","title":"Response Format"},{"location":"schema/#with-errors","text":"{ \"data\" : { \"user\" : None }, \"errors\" : [ { \"message\" : \"User not found\" , \"path\" : [ \"user\" ], \"locations\" : [{ \"line\" : 1 , \"column\" : 3 }] } ] }","title":"With Errors"},{"location":"schema/#partial-results","text":"GraphQL can return partial data with errors: { \"data\" : { \"users\" : [ { \"name\" : \"Alice\" }, None , # This user's resolver failed { \"name\" : \"Charlie\" } ] }, \"errors\" : [ { \"message\" : \"Failed to fetch user\" , \"path\" : [ \"users\" , 1 ]} ] }","title":"Partial Results"},{"location":"schema/#subscriptions","text":"Use subscribe() for real-time data: stream = schema . subscribe ( \"subscription { messages { text } }\" ) async for payload in stream : print ( payload [ \"data\" ][ \"messages\" ][ \"text\" ]) See Subscriptions for details.","title":"Subscriptions"},{"location":"schema/#schema-introspection","text":"","title":"Schema Introspection"},{"location":"schema/#sdl-output","text":"Get the GraphQL Schema Definition Language: print ( schema . sdl ()) Output: type Query { hello : String ! users : [ User !]! } type User { id : ID ! name : String ! email : String ! }","title":"SDL Output"},{"location":"schema/#type-discovery","text":"Grommet automatically discovers types referenced by your schema: @gm . type @dataclass class User : id : gm . ID name : str posts : list [ \"Post\" ] @gm . type @dataclass class Post : id : gm . ID title : str author : User @gm . type @dataclass class Query : @gm . field @staticmethod async def user ( parent , info , id : gm . ID ) -> User : ... # Both User and Post are included in the schema schema = gm . Schema ( query = Query )","title":"Type Discovery"},{"location":"schema/#schema-requirements","text":"","title":"Schema Requirements"},{"location":"schema/#query-type-required","text":"Every schema must have a query type: # \u2705 Valid schema = gm . Schema ( query = Query ) # \u274c Invalid - raises GrommetSchemaError schema = gm . Schema ( query = None )","title":"Query Type Required"},{"location":"schema/#types-must-be-decorated","text":"All types used in the schema must be decorated: # \u2705 Valid - User is decorated @gm . type @dataclass class User : name : str # \u274c Invalid - PlainClass is not decorated @dataclass class PlainClass : name : str","title":"Types Must Be Decorated"},{"location":"schema/#complete-example","text":"import asyncio from dataclasses import dataclass from typing import TYPE_CHECKING import grommet as gm if TYPE_CHECKING : from collections.abc import AsyncIterator @gm . type @dataclass class User : id : gm . ID name : str email : str @gm . type @dataclass class Query : @gm . field @staticmethod async def user ( parent , info , id : gm . ID ) -> User | None : users = { \"1\" : User ( id = gm . ID ( \"1\" ), name = \"Alice\" , email = \"alice@example.com\" )} return users . get ( str ( id )) @gm . field @staticmethod async def users ( parent , info ) -> list [ User ]: return [ User ( id = gm . ID ( \"1\" ), name = \"Alice\" , email = \"alice@example.com\" ), User ( id = gm . ID ( \"2\" ), name = \"Bob\" , email = \"bob@example.com\" ), ] @gm . input @dataclass class CreateUserInput : name : str email : str @gm . type @dataclass class Mutation : @gm . field @staticmethod async def create_user ( parent , info , input : CreateUserInput ) -> User : return User ( id = gm . ID ( \"3\" ), name = input . name , email = input . email , ) @gm . type @dataclass class Subscription : @gm . field @staticmethod async def countdown ( parent , info , start : int ) -> \"AsyncIterator[int]\" : for i in range ( start , 0 , - 1 ): yield i await asyncio . sleep ( 1 ) schema = gm . Schema ( query = Query , mutation = Mutation , subscription = Subscription , ) async def main (): # Query result = await schema . execute ( '{ user(id: \"1\") { name } }' ) print ( result ) # Mutation result = await schema . execute ( ''' mutation { createUser(input: { name: \"Charlie\", email: \"charlie@example.com\" }) { id name } } ''' ) print ( result ) # Subscription stream = schema . subscribe ( \"subscription { countdown(start: 3) }\" ) async for payload in stream : print ( payload ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Complete Example"},{"location":"subscriptions/","text":"Subscriptions \u00b6 Subscriptions enable real-time updates by streaming data to clients. They're ideal for notifications, live feeds, and collaborative features. Defining Subscriptions \u00b6 Create a subscription type with async generator resolvers: from dataclasses import dataclass from typing import TYPE_CHECKING import grommet as gm if TYPE_CHECKING : from collections.abc import AsyncIterator @gm . type @dataclass class Subscription : @gm . field @staticmethod async def countdown ( parent , info , start : int ) -> \"AsyncIterator[int]\" : for i in range ( start , 0 , - 1 ): yield i await asyncio . sleep ( 1 ) Creating a Schema with Subscriptions \u00b6 schema = gm . Schema ( query = Query , subscription = Subscription , ) Subscribing \u00b6 Use schema.subscribe() to get a stream: stream = schema . subscribe ( \"subscription { countdown(start: 5) }\" ) async for payload in stream : print ( payload [ \"data\" ][ \"countdown\" ]) # Prints: 5, 4, 3, 2, 1 Subscription Stream \u00b6 The stream returned by subscribe() is an async iterator with these methods: stream = schema . subscribe ( \"subscription { countdown(start: 3) }\" ) # Async iteration async for payload in stream : print ( payload ) # Manual iteration payload = await stream . __anext__ () # Close the stream early await stream . aclose () Subscription Arguments \u00b6 Like queries, subscriptions can have arguments: @gm . type @dataclass class Subscription : @gm . field @staticmethod async def messages ( parent , info , channel : str ) -> \"AsyncIterator[Message]\" : async for message in message_queue . subscribe ( channel ): yield message subscription { messages ( channel : \"general\" ) { id text author } } Variables \u00b6 Pass variables to subscriptions: stream = schema . subscribe ( \"\"\" subscription ($channel: String!) { messages(channel: $channel) { text } } \"\"\" , variables = { \"channel\" : \"general\" }, ) Context and Root \u00b6 Like queries, subscriptions can receive context and root values: stream = schema . subscribe ( \"subscription { notifications }\" , context = { \"user_id\" : \"123\" }, root = { \"tenant\" : \"acme\" }, ) Access them in resolvers: @gm . field @staticmethod async def notifications ( parent , info ) -> \"AsyncIterator[Notification]\" : user_id = info . context [ \"user_id\" ] async for notification in get_user_notifications ( user_id ): yield notification Real-World Examples \u00b6 Chat Messages \u00b6 from asyncio import Queue message_queues : dict [ str , Queue ] = {} @gm . type @dataclass class Subscription : @gm . field @staticmethod async def chat_messages ( parent , info , room : str ) -> \"AsyncIterator[ChatMessage]\" : queue = message_queues . setdefault ( room , Queue ()) while True : message = await queue . get () yield message Live Updates \u00b6 @gm . type @dataclass class Subscription : @gm . field @staticmethod async def order_status ( parent , info , order_id : gm . ID ) -> \"AsyncIterator[OrderStatus]\" : async for status in watch_order_status ( order_id ): yield status if status . is_final : break Periodic Updates \u00b6 import asyncio @gm . type @dataclass class Subscription : @gm . field @staticmethod async def server_time ( parent , info ) -> \"AsyncIterator[str]\" : while True : yield datetime . now () . isoformat () await asyncio . sleep ( 1 ) Handling Errors \u00b6 Errors in subscription resolvers are yielded as error payloads: @gm . field @staticmethod async def risky_stream ( parent , info ) -> \"AsyncIterator[int]\" : for i in range ( 5 ): if i == 3 : raise ValueError ( \"Something went wrong!\" ) yield i Client receives: # First three payloads { \"data\" : { \"riskyStream\" : 0 }} { \"data\" : { \"riskyStream\" : 1 }} { \"data\" : { \"riskyStream\" : 2 }} # Error payload { \"data\" : { \"riskyStream\" : null }, \"errors\" : [ ... ]} Closing Subscriptions \u00b6 Always close subscriptions when done to release resources: stream = schema . subscribe ( \"subscription { updates }\" ) try : async for payload in stream : if should_stop ( payload ): break finally : await stream . aclose () Or use async context managers: stream = schema . subscribe ( \"subscription { updates }\" ) async for payload in stream : process ( payload ) if done : await stream . aclose () break Return Type Annotations \u00b6 Subscription resolvers must have an AsyncIterator return type: from typing import TYPE_CHECKING if TYPE_CHECKING : from collections.abc import AsyncIterator @gm . field @staticmethod async def events ( parent , info ) -> \"AsyncIterator[Event]\" : ... Note Use TYPE_CHECKING to avoid runtime import of AsyncIterator . Nullable Subscriptions \u00b6 For subscriptions that might yield None : @gm . field @staticmethod async def maybe_events ( parent , info ) -> \"AsyncIterator[Event | None]\" : async for event in event_stream (): yield event if event . is_valid else None","title":"Subscriptions"},{"location":"subscriptions/#subscriptions","text":"Subscriptions enable real-time updates by streaming data to clients. They're ideal for notifications, live feeds, and collaborative features.","title":"Subscriptions"},{"location":"subscriptions/#defining-subscriptions","text":"Create a subscription type with async generator resolvers: from dataclasses import dataclass from typing import TYPE_CHECKING import grommet as gm if TYPE_CHECKING : from collections.abc import AsyncIterator @gm . type @dataclass class Subscription : @gm . field @staticmethod async def countdown ( parent , info , start : int ) -> \"AsyncIterator[int]\" : for i in range ( start , 0 , - 1 ): yield i await asyncio . sleep ( 1 )","title":"Defining Subscriptions"},{"location":"subscriptions/#creating-a-schema-with-subscriptions","text":"schema = gm . Schema ( query = Query , subscription = Subscription , )","title":"Creating a Schema with Subscriptions"},{"location":"subscriptions/#subscribing","text":"Use schema.subscribe() to get a stream: stream = schema . subscribe ( \"subscription { countdown(start: 5) }\" ) async for payload in stream : print ( payload [ \"data\" ][ \"countdown\" ]) # Prints: 5, 4, 3, 2, 1","title":"Subscribing"},{"location":"subscriptions/#subscription-stream","text":"The stream returned by subscribe() is an async iterator with these methods: stream = schema . subscribe ( \"subscription { countdown(start: 3) }\" ) # Async iteration async for payload in stream : print ( payload ) # Manual iteration payload = await stream . __anext__ () # Close the stream early await stream . aclose ()","title":"Subscription Stream"},{"location":"subscriptions/#subscription-arguments","text":"Like queries, subscriptions can have arguments: @gm . type @dataclass class Subscription : @gm . field @staticmethod async def messages ( parent , info , channel : str ) -> \"AsyncIterator[Message]\" : async for message in message_queue . subscribe ( channel ): yield message subscription { messages ( channel : \"general\" ) { id text author } }","title":"Subscription Arguments"},{"location":"subscriptions/#variables","text":"Pass variables to subscriptions: stream = schema . subscribe ( \"\"\" subscription ($channel: String!) { messages(channel: $channel) { text } } \"\"\" , variables = { \"channel\" : \"general\" }, )","title":"Variables"},{"location":"subscriptions/#context-and-root","text":"Like queries, subscriptions can receive context and root values: stream = schema . subscribe ( \"subscription { notifications }\" , context = { \"user_id\" : \"123\" }, root = { \"tenant\" : \"acme\" }, ) Access them in resolvers: @gm . field @staticmethod async def notifications ( parent , info ) -> \"AsyncIterator[Notification]\" : user_id = info . context [ \"user_id\" ] async for notification in get_user_notifications ( user_id ): yield notification","title":"Context and Root"},{"location":"subscriptions/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"subscriptions/#chat-messages","text":"from asyncio import Queue message_queues : dict [ str , Queue ] = {} @gm . type @dataclass class Subscription : @gm . field @staticmethod async def chat_messages ( parent , info , room : str ) -> \"AsyncIterator[ChatMessage]\" : queue = message_queues . setdefault ( room , Queue ()) while True : message = await queue . get () yield message","title":"Chat Messages"},{"location":"subscriptions/#live-updates","text":"@gm . type @dataclass class Subscription : @gm . field @staticmethod async def order_status ( parent , info , order_id : gm . ID ) -> \"AsyncIterator[OrderStatus]\" : async for status in watch_order_status ( order_id ): yield status if status . is_final : break","title":"Live Updates"},{"location":"subscriptions/#periodic-updates","text":"import asyncio @gm . type @dataclass class Subscription : @gm . field @staticmethod async def server_time ( parent , info ) -> \"AsyncIterator[str]\" : while True : yield datetime . now () . isoformat () await asyncio . sleep ( 1 )","title":"Periodic Updates"},{"location":"subscriptions/#handling-errors","text":"Errors in subscription resolvers are yielded as error payloads: @gm . field @staticmethod async def risky_stream ( parent , info ) -> \"AsyncIterator[int]\" : for i in range ( 5 ): if i == 3 : raise ValueError ( \"Something went wrong!\" ) yield i Client receives: # First three payloads { \"data\" : { \"riskyStream\" : 0 }} { \"data\" : { \"riskyStream\" : 1 }} { \"data\" : { \"riskyStream\" : 2 }} # Error payload { \"data\" : { \"riskyStream\" : null }, \"errors\" : [ ... ]}","title":"Handling Errors"},{"location":"subscriptions/#closing-subscriptions","text":"Always close subscriptions when done to release resources: stream = schema . subscribe ( \"subscription { updates }\" ) try : async for payload in stream : if should_stop ( payload ): break finally : await stream . aclose () Or use async context managers: stream = schema . subscribe ( \"subscription { updates }\" ) async for payload in stream : process ( payload ) if done : await stream . aclose () break","title":"Closing Subscriptions"},{"location":"subscriptions/#return-type-annotations","text":"Subscription resolvers must have an AsyncIterator return type: from typing import TYPE_CHECKING if TYPE_CHECKING : from collections.abc import AsyncIterator @gm . field @staticmethod async def events ( parent , info ) -> \"AsyncIterator[Event]\" : ... Note Use TYPE_CHECKING to avoid runtime import of AsyncIterator .","title":"Return Type Annotations"},{"location":"subscriptions/#nullable-subscriptions","text":"For subscriptions that might yield None : @gm . field @staticmethod async def maybe_events ( parent , info ) -> \"AsyncIterator[Event | None]\" : async for event in event_stream (): yield event if event . is_valid else None","title":"Nullable Subscriptions"},{"location":"types/enums/","text":"Enums \u00b6 Enums represent a fixed set of allowed values. They're useful for fields that should only accept specific options. Defining Enums \u00b6 Use the @gm.enum decorator on a Python enum.Enum subclass: import enum import grommet as gm @gm . enum class Status ( enum . Enum ): ACTIVE = \"active\" INACTIVE = \"inactive\" PENDING = \"pending\" This generates: enum Status { ACTIVE INACTIVE PENDING } Using Enums \u00b6 Enums can be used in type fields and resolver arguments: from dataclasses import dataclass @gm . type @dataclass class User : id : gm . ID name : str status : Status @gm . type @dataclass class Query : @gm . field @staticmethod async def users_by_status ( parent , info , status : Status ) -> list [ User ]: # status is a Status enum instance return [ User ( id = gm . ID ( \"1\" ), name = \"Alice\" , status = status ) ] Query: { usersByStatus ( status : ACTIVE ) { name status } } Enum Values \u00b6 The GraphQL enum values are the Python enum member names (uppercase by convention): @gm . enum class Priority ( enum . Enum ): LOW = 1 MEDIUM = 2 HIGH = 3 CRITICAL = 4 enum Priority { LOW MEDIUM HIGH CRITICAL } Note The Python enum values ( 1 , 2 , 3 , 4 ) are internal. GraphQL uses the member names ( LOW , MEDIUM , etc.). Custom Names and Descriptions \u00b6 @gm . enum ( name = \"TaskStatus\" , description = \"The current state of a task\" ) class Status ( enum . Enum ): ACTIVE = \"active\" INACTIVE = \"inactive\" \"\"\"The current state of a task\"\"\" enum TaskStatus { ACTIVE INACTIVE } String Enums \u00b6 For enums backed by string values, use enum.StrEnum (Python 3.11+): import enum @gm . enum class Color ( enum . StrEnum ): RED = \"red\" GREEN = \"green\" BLUE = \"blue\" Integer Enums \u00b6 import enum @gm . enum class ErrorCode ( enum . IntEnum ): NOT_FOUND = 404 SERVER_ERROR = 500 BAD_REQUEST = 400 Nullable Enums \u00b6 Make enum fields optional with union types: @gm . type @dataclass class Task : id : gm . ID title : str priority : Priority | None = None Enums in Input Types \u00b6 Enums work in input types too: @gm . input @dataclass class CreateTaskInput : title : str priority : Priority = Priority . MEDIUM mutation { createTask ( input : { title : \"Fix bug\" , priority : HIGH }) { id priority } } Enums as List Items \u00b6 @gm . type @dataclass class User : id : gm . ID name : str permissions : list [ Permission ] { user ( id : \"1\" ) { permissions # Returns [\"READ\", \"WRITE\"] } } Best Practices \u00b6 Use UPPERCASE names - Follow GraphQL conventions for enum values Keep enums focused - Each enum should represent a single concept Document values - Use descriptions to explain what each value means Prefer enums over strings - For fixed sets of values, enums provide type safety","title":"Enums"},{"location":"types/enums/#enums","text":"Enums represent a fixed set of allowed values. They're useful for fields that should only accept specific options.","title":"Enums"},{"location":"types/enums/#defining-enums","text":"Use the @gm.enum decorator on a Python enum.Enum subclass: import enum import grommet as gm @gm . enum class Status ( enum . Enum ): ACTIVE = \"active\" INACTIVE = \"inactive\" PENDING = \"pending\" This generates: enum Status { ACTIVE INACTIVE PENDING }","title":"Defining Enums"},{"location":"types/enums/#using-enums","text":"Enums can be used in type fields and resolver arguments: from dataclasses import dataclass @gm . type @dataclass class User : id : gm . ID name : str status : Status @gm . type @dataclass class Query : @gm . field @staticmethod async def users_by_status ( parent , info , status : Status ) -> list [ User ]: # status is a Status enum instance return [ User ( id = gm . ID ( \"1\" ), name = \"Alice\" , status = status ) ] Query: { usersByStatus ( status : ACTIVE ) { name status } }","title":"Using Enums"},{"location":"types/enums/#enum-values","text":"The GraphQL enum values are the Python enum member names (uppercase by convention): @gm . enum class Priority ( enum . Enum ): LOW = 1 MEDIUM = 2 HIGH = 3 CRITICAL = 4 enum Priority { LOW MEDIUM HIGH CRITICAL } Note The Python enum values ( 1 , 2 , 3 , 4 ) are internal. GraphQL uses the member names ( LOW , MEDIUM , etc.).","title":"Enum Values"},{"location":"types/enums/#custom-names-and-descriptions","text":"@gm . enum ( name = \"TaskStatus\" , description = \"The current state of a task\" ) class Status ( enum . Enum ): ACTIVE = \"active\" INACTIVE = \"inactive\" \"\"\"The current state of a task\"\"\" enum TaskStatus { ACTIVE INACTIVE }","title":"Custom Names and Descriptions"},{"location":"types/enums/#string-enums","text":"For enums backed by string values, use enum.StrEnum (Python 3.11+): import enum @gm . enum class Color ( enum . StrEnum ): RED = \"red\" GREEN = \"green\" BLUE = \"blue\"","title":"String Enums"},{"location":"types/enums/#integer-enums","text":"import enum @gm . enum class ErrorCode ( enum . IntEnum ): NOT_FOUND = 404 SERVER_ERROR = 500 BAD_REQUEST = 400","title":"Integer Enums"},{"location":"types/enums/#nullable-enums","text":"Make enum fields optional with union types: @gm . type @dataclass class Task : id : gm . ID title : str priority : Priority | None = None","title":"Nullable Enums"},{"location":"types/enums/#enums-in-input-types","text":"Enums work in input types too: @gm . input @dataclass class CreateTaskInput : title : str priority : Priority = Priority . MEDIUM mutation { createTask ( input : { title : \"Fix bug\" , priority : HIGH }) { id priority } }","title":"Enums in Input Types"},{"location":"types/enums/#enums-as-list-items","text":"@gm . type @dataclass class User : id : gm . ID name : str permissions : list [ Permission ] { user ( id : \"1\" ) { permissions # Returns [\"READ\", \"WRITE\"] } }","title":"Enums as List Items"},{"location":"types/enums/#best-practices","text":"Use UPPERCASE names - Follow GraphQL conventions for enum values Keep enums focused - Each enum should represent a single concept Document values - Use descriptions to explain what each value means Prefer enums over strings - For fixed sets of values, enums provide type safety","title":"Best Practices"},{"location":"types/input-types/","text":"Input Types \u00b6 Input types are used to pass complex objects as arguments to queries and mutations. Unlike object types, input types cannot have resolvers and are used exclusively for input. Defining Input Types \u00b6 Use the @gm.input decorator on a dataclass: from dataclasses import dataclass import grommet as gm @gm . input @dataclass class CreateUserInput : name : str email : str age : int | None = None This generates: input CreateUserInput { name : String ! email : String ! age : Int } Using Input Types \u00b6 Input types are used as resolver arguments: @gm . type @dataclass class User : id : gm . ID name : str email : str @gm . type @dataclass class Mutation : @gm . field @staticmethod async def create_user ( parent , info , input : CreateUserInput ) -> User : # input is automatically converted to CreateUserInput instance return User ( id = gm . ID ( \"1\" ), name = input . name , email = input . email , ) Query: mutation { createUser ( input : { name : \"Alice\" , email : \"alice@example.com\" }) { id name } } Default Values \u00b6 Input fields can have default values: @gm . input @dataclass class PaginationInput : page : int = 1 per_page : int = 10 input PaginationInput { page : Int = 1 perPage : Int = 10 } Default Factories \u00b6 For mutable defaults like lists, use dataclasses.field with default_factory : from dataclasses import dataclass , field import grommet as gm @gm . input @dataclass class FilterInput : tags : list [ str ] = field ( default_factory = list ) status : str = \"active\" Nested Input Types \u00b6 Input types can contain other input types: @gm . input @dataclass class AddressInput : street : str city : str country : str @gm . input @dataclass class CreateUserInput : name : str email : str address : AddressInput | None = None Custom Names and Descriptions \u00b6 @gm . input ( name = \"UserCreationInput\" , description = \"Data required to create a new user\" ) @dataclass class CreateUserInput : name : str email : str Validation \u00b6 Input values are automatically validated against the schema. Invalid inputs will result in GraphQL errors: # This will error if email is required but not provided mutation { createUser ( input : { name : \"Alice\" }) { id } } Input vs Object Types \u00b6 Feature Object Type ( @gm.type ) Input Type ( @gm.input ) Used for Output/Response Input/Arguments Resolvers \u2705 Allowed \u274c Not allowed Circular references \u2705 Allowed \u274c Not allowed Interfaces \u2705 Can implement \u274c Cannot implement ID Fields \u00b6 Use gm.ID for GraphQL ID fields in inputs: @gm . input @dataclass class UpdateUserInput : id : gm . ID name : str | None = None email : str | None = None Internal Fields \u00b6 Like object types, input types support internal fields: @gm . input @dataclass class CreateUserInput : name : str email : str _tracking_id : gm . Internal [ str ] = \"\" # Not exposed in GraphQL","title":"Input Types"},{"location":"types/input-types/#input-types","text":"Input types are used to pass complex objects as arguments to queries and mutations. Unlike object types, input types cannot have resolvers and are used exclusively for input.","title":"Input Types"},{"location":"types/input-types/#defining-input-types","text":"Use the @gm.input decorator on a dataclass: from dataclasses import dataclass import grommet as gm @gm . input @dataclass class CreateUserInput : name : str email : str age : int | None = None This generates: input CreateUserInput { name : String ! email : String ! age : Int }","title":"Defining Input Types"},{"location":"types/input-types/#using-input-types","text":"Input types are used as resolver arguments: @gm . type @dataclass class User : id : gm . ID name : str email : str @gm . type @dataclass class Mutation : @gm . field @staticmethod async def create_user ( parent , info , input : CreateUserInput ) -> User : # input is automatically converted to CreateUserInput instance return User ( id = gm . ID ( \"1\" ), name = input . name , email = input . email , ) Query: mutation { createUser ( input : { name : \"Alice\" , email : \"alice@example.com\" }) { id name } }","title":"Using Input Types"},{"location":"types/input-types/#default-values","text":"Input fields can have default values: @gm . input @dataclass class PaginationInput : page : int = 1 per_page : int = 10 input PaginationInput { page : Int = 1 perPage : Int = 10 }","title":"Default Values"},{"location":"types/input-types/#default-factories","text":"For mutable defaults like lists, use dataclasses.field with default_factory : from dataclasses import dataclass , field import grommet as gm @gm . input @dataclass class FilterInput : tags : list [ str ] = field ( default_factory = list ) status : str = \"active\"","title":"Default Factories"},{"location":"types/input-types/#nested-input-types","text":"Input types can contain other input types: @gm . input @dataclass class AddressInput : street : str city : str country : str @gm . input @dataclass class CreateUserInput : name : str email : str address : AddressInput | None = None","title":"Nested Input Types"},{"location":"types/input-types/#custom-names-and-descriptions","text":"@gm . input ( name = \"UserCreationInput\" , description = \"Data required to create a new user\" ) @dataclass class CreateUserInput : name : str email : str","title":"Custom Names and Descriptions"},{"location":"types/input-types/#validation","text":"Input values are automatically validated against the schema. Invalid inputs will result in GraphQL errors: # This will error if email is required but not provided mutation { createUser ( input : { name : \"Alice\" }) { id } }","title":"Validation"},{"location":"types/input-types/#input-vs-object-types","text":"Feature Object Type ( @gm.type ) Input Type ( @gm.input ) Used for Output/Response Input/Arguments Resolvers \u2705 Allowed \u274c Not allowed Circular references \u2705 Allowed \u274c Not allowed Interfaces \u2705 Can implement \u274c Cannot implement","title":"Input vs Object Types"},{"location":"types/input-types/#id-fields","text":"Use gm.ID for GraphQL ID fields in inputs: @gm . input @dataclass class UpdateUserInput : id : gm . ID name : str | None = None email : str | None = None","title":"ID Fields"},{"location":"types/input-types/#internal-fields","text":"Like object types, input types support internal fields: @gm . input @dataclass class CreateUserInput : name : str email : str _tracking_id : gm . Internal [ str ] = \"\" # Not exposed in GraphQL","title":"Internal Fields"},{"location":"types/interfaces/","text":"Interfaces \u00b6 Interfaces define a set of fields that multiple types can implement. They enable polymorphism in your GraphQL schema. Defining Interfaces \u00b6 Use the @gm.interface decorator: from dataclasses import dataclass import grommet as gm @gm . interface @dataclass class Node : id : gm . ID This generates: interface Node { id : ID ! } Implementing Interfaces \u00b6 Types implement interfaces using the implements parameter: @gm . interface @dataclass class Node : id : gm . ID @gm . type ( implements = [ Node ]) @dataclass class User : id : gm . ID name : str email : str @gm . type ( implements = [ Node ]) @dataclass class Post : id : gm . ID title : str content : str This generates: interface Node { id : ID ! } type User implements Node { id : ID ! name : String ! email : String ! } type Post implements Node { id : ID ! title : String ! content : String ! } Querying Interfaces \u00b6 When querying an interface, use inline fragments to access type-specific fields: query { node ( id : \"1\" ) { id ... on User { name email } ... on Post { title } } } Interface Fields with Resolvers \u00b6 Interfaces can have fields with resolvers: @gm . interface @dataclass class Timestamped : created_at : str updated_at : str @gm . field @staticmethod async def age_in_days ( parent , info ) -> int : # Calculate days since creation from datetime import datetime created = datetime . fromisoformat ( parent . created_at ) return ( datetime . now () - created ) . days Note Interface resolvers define the field signature but are not directly called. Each implementing type must provide its own implementation or inherit the field. Multiple Interfaces \u00b6 Types can implement multiple interfaces: @gm . interface @dataclass class Node : id : gm . ID @gm . interface @dataclass class Timestamped : created_at : str updated_at : str @gm . type ( implements = [ Node , Timestamped ]) @dataclass class User : id : gm . ID created_at : str updated_at : str name : str Interface Inheritance \u00b6 Interfaces can extend other interfaces: @gm . interface @dataclass class Node : id : gm . ID @gm . interface ( implements = [ Node ]) @dataclass class Entity : id : gm . ID name : str interface Node { id : ID ! } interface Entity implements Node { id : ID ! name : String ! } Custom Names and Descriptions \u00b6 @gm . interface ( name = \"Identifiable\" , description = \"An object with a unique identifier\" ) @dataclass class Node : id : gm . ID Best Practices \u00b6 Keep interfaces focused - Each interface should represent a single concept Use for shared behavior - Interfaces work best when multiple types share common fields Prefer composition - Types can implement multiple interfaces for flexibility Document interfaces - Use descriptions to explain the purpose of each interface","title":"Interfaces"},{"location":"types/interfaces/#interfaces","text":"Interfaces define a set of fields that multiple types can implement. They enable polymorphism in your GraphQL schema.","title":"Interfaces"},{"location":"types/interfaces/#defining-interfaces","text":"Use the @gm.interface decorator: from dataclasses import dataclass import grommet as gm @gm . interface @dataclass class Node : id : gm . ID This generates: interface Node { id : ID ! }","title":"Defining Interfaces"},{"location":"types/interfaces/#implementing-interfaces","text":"Types implement interfaces using the implements parameter: @gm . interface @dataclass class Node : id : gm . ID @gm . type ( implements = [ Node ]) @dataclass class User : id : gm . ID name : str email : str @gm . type ( implements = [ Node ]) @dataclass class Post : id : gm . ID title : str content : str This generates: interface Node { id : ID ! } type User implements Node { id : ID ! name : String ! email : String ! } type Post implements Node { id : ID ! title : String ! content : String ! }","title":"Implementing Interfaces"},{"location":"types/interfaces/#querying-interfaces","text":"When querying an interface, use inline fragments to access type-specific fields: query { node ( id : \"1\" ) { id ... on User { name email } ... on Post { title } } }","title":"Querying Interfaces"},{"location":"types/interfaces/#interface-fields-with-resolvers","text":"Interfaces can have fields with resolvers: @gm . interface @dataclass class Timestamped : created_at : str updated_at : str @gm . field @staticmethod async def age_in_days ( parent , info ) -> int : # Calculate days since creation from datetime import datetime created = datetime . fromisoformat ( parent . created_at ) return ( datetime . now () - created ) . days Note Interface resolvers define the field signature but are not directly called. Each implementing type must provide its own implementation or inherit the field.","title":"Interface Fields with Resolvers"},{"location":"types/interfaces/#multiple-interfaces","text":"Types can implement multiple interfaces: @gm . interface @dataclass class Node : id : gm . ID @gm . interface @dataclass class Timestamped : created_at : str updated_at : str @gm . type ( implements = [ Node , Timestamped ]) @dataclass class User : id : gm . ID created_at : str updated_at : str name : str","title":"Multiple Interfaces"},{"location":"types/interfaces/#interface-inheritance","text":"Interfaces can extend other interfaces: @gm . interface @dataclass class Node : id : gm . ID @gm . interface ( implements = [ Node ]) @dataclass class Entity : id : gm . ID name : str interface Node { id : ID ! } interface Entity implements Node { id : ID ! name : String ! }","title":"Interface Inheritance"},{"location":"types/interfaces/#custom-names-and-descriptions","text":"@gm . interface ( name = \"Identifiable\" , description = \"An object with a unique identifier\" ) @dataclass class Node : id : gm . ID","title":"Custom Names and Descriptions"},{"location":"types/interfaces/#best-practices","text":"Keep interfaces focused - Each interface should represent a single concept Use for shared behavior - Interfaces work best when multiple types share common fields Prefer composition - Types can implement multiple interfaces for flexibility Document interfaces - Use descriptions to explain the purpose of each interface","title":"Best Practices"},{"location":"types/object-types/","text":"Object Types \u00b6 Object types are the building blocks of a GraphQL schema. They define the structure of your data and the relationships between different types. Defining Object Types \u00b6 In Grommet, object types are Python dataclasses decorated with @gm.type : from dataclasses import dataclass import grommet as gm @gm . type @dataclass class User : id : gm . ID name : str email : str This generates the following GraphQL schema: type User { id : ID ! name : String ! email : String ! } Type Mapping \u00b6 Grommet automatically maps Python types to GraphQL types: Python Type GraphQL Type str String! int Int! float Float! bool Boolean! gm.ID ID! list[T] [T!]! T \\| None T (nullable) Optional Fields \u00b6 Use None union types to make fields nullable: @gm . type @dataclass class User : id : gm . ID name : str nickname : str | None = None # Nullable with default type User { id : ID ! name : String ! nickname : String } Nested Types \u00b6 Types can reference other types: @gm . type @dataclass class Address : street : str city : str country : str @gm . type @dataclass class User : id : gm . ID name : str address : Address Lists \u00b6 Use Python's list type for arrays: @gm . type @dataclass class User : id : gm . ID name : str tags : list [ str ] type User { id : ID ! name : String ! tags : [ String !]! } Custom Type Names \u00b6 Override the GraphQL type name using the name parameter: @gm . type ( name = \"Person\" ) @dataclass class User : id : gm . ID name : str type Person { id : ID ! name : String ! } Descriptions \u00b6 Add descriptions that appear in your GraphQL schema: @gm . type ( description = \"A user in the system\" ) @dataclass class User : id : gm . ID name : str \"\"\"A user in the system\"\"\" type User { id : ID ! name : String ! } Fields with Resolvers \u00b6 Fields can have custom resolvers using @gm.field : @gm . type @dataclass class User : id : gm . ID first_name : str last_name : str @gm . field @staticmethod async def full_name ( parent , info ) -> str : return f \" { parent . first_name } { parent . last_name } \" See Resolvers for more details. Internal Fields \u00b6 Fields can be excluded from the GraphQL schema while remaining available in Python: @gm . type @dataclass class User : id : gm . ID name : str _internal_id : int # Excluded (underscore prefix) password_hash : gm . Internal [ str ] # Excluded (Internal wrapper) Three ways to mark fields as internal: Underscore prefix - Fields starting with _ gm.Internal[T] - Wrap the type annotation gm.Private[T] - Alias for Internal Implementing Interfaces \u00b6 Types can implement interfaces: @gm . interface @dataclass class Node : id : gm . ID @gm . type ( implements = [ Node ]) @dataclass class User : id : gm . ID name : str See Interfaces for more details.","title":"Object Types"},{"location":"types/object-types/#object-types","text":"Object types are the building blocks of a GraphQL schema. They define the structure of your data and the relationships between different types.","title":"Object Types"},{"location":"types/object-types/#defining-object-types","text":"In Grommet, object types are Python dataclasses decorated with @gm.type : from dataclasses import dataclass import grommet as gm @gm . type @dataclass class User : id : gm . ID name : str email : str This generates the following GraphQL schema: type User { id : ID ! name : String ! email : String ! }","title":"Defining Object Types"},{"location":"types/object-types/#type-mapping","text":"Grommet automatically maps Python types to GraphQL types: Python Type GraphQL Type str String! int Int! float Float! bool Boolean! gm.ID ID! list[T] [T!]! T \\| None T (nullable)","title":"Type Mapping"},{"location":"types/object-types/#optional-fields","text":"Use None union types to make fields nullable: @gm . type @dataclass class User : id : gm . ID name : str nickname : str | None = None # Nullable with default type User { id : ID ! name : String ! nickname : String }","title":"Optional Fields"},{"location":"types/object-types/#nested-types","text":"Types can reference other types: @gm . type @dataclass class Address : street : str city : str country : str @gm . type @dataclass class User : id : gm . ID name : str address : Address","title":"Nested Types"},{"location":"types/object-types/#lists","text":"Use Python's list type for arrays: @gm . type @dataclass class User : id : gm . ID name : str tags : list [ str ] type User { id : ID ! name : String ! tags : [ String !]! }","title":"Lists"},{"location":"types/object-types/#custom-type-names","text":"Override the GraphQL type name using the name parameter: @gm . type ( name = \"Person\" ) @dataclass class User : id : gm . ID name : str type Person { id : ID ! name : String ! }","title":"Custom Type Names"},{"location":"types/object-types/#descriptions","text":"Add descriptions that appear in your GraphQL schema: @gm . type ( description = \"A user in the system\" ) @dataclass class User : id : gm . ID name : str \"\"\"A user in the system\"\"\" type User { id : ID ! name : String ! }","title":"Descriptions"},{"location":"types/object-types/#fields-with-resolvers","text":"Fields can have custom resolvers using @gm.field : @gm . type @dataclass class User : id : gm . ID first_name : str last_name : str @gm . field @staticmethod async def full_name ( parent , info ) -> str : return f \" { parent . first_name } { parent . last_name } \" See Resolvers for more details.","title":"Fields with Resolvers"},{"location":"types/object-types/#internal-fields","text":"Fields can be excluded from the GraphQL schema while remaining available in Python: @gm . type @dataclass class User : id : gm . ID name : str _internal_id : int # Excluded (underscore prefix) password_hash : gm . Internal [ str ] # Excluded (Internal wrapper) Three ways to mark fields as internal: Underscore prefix - Fields starting with _ gm.Internal[T] - Wrap the type annotation gm.Private[T] - Alias for Internal","title":"Internal Fields"},{"location":"types/object-types/#implementing-interfaces","text":"Types can implement interfaces: @gm . interface @dataclass class Node : id : gm . ID @gm . type ( implements = [ Node ]) @dataclass class User : id : gm . ID name : str See Interfaces for more details.","title":"Implementing Interfaces"},{"location":"types/scalars/","text":"Custom Scalars \u00b6 Scalars are the leaf values in GraphQL. While GraphQL provides built-in scalars ( String , Int , Float , Boolean , ID ), you can define custom scalars for specialized data types. Built-in Scalars \u00b6 Grommet maps Python types to GraphQL scalars automatically: Python Type GraphQL Scalar str String int Int float Float bool Boolean gm.ID ID Defining Custom Scalars \u00b6 Use the @gm.scalar decorator with serialize and parse_value functions: from dataclasses import dataclass from datetime import date import grommet as gm @gm . scalar ( serialize = lambda value : value . isoformat (), parse_value = lambda value : date . fromisoformat ( value ), ) @dataclass class Date : _value : date def __init__ ( self , value : date | str ): if isinstance ( value , str ): value = date . fromisoformat ( value ) object . __setattr__ ( self , \"_value\" , value ) def isoformat ( self ) -> str : return self . _value . isoformat () serialize - Converts Python value to JSON-compatible output parse_value - Converts JSON input to Python value Using Custom Scalars \u00b6 Once defined, use scalars like any other type: @gm . type @dataclass class Event : id : gm . ID name : str date : Date @gm . type @dataclass class Query : @gm . field @staticmethod async def event ( parent , info , id : gm . ID ) -> Event : return Event ( id = id , name = \"Conference\" , date = Date ( date ( 2024 , 6 , 15 )), ) Query: { event ( id : \"1\" ) { name date # Returns \"2024-06-15\" } } Scalar Parameters \u00b6 name \u00b6 Override the GraphQL scalar name: @gm . scalar ( name = \"DateTime\" , serialize = lambda v : v . isoformat (), parse_value = lambda v : datetime . fromisoformat ( v ), ) @dataclass class MyDateTime : ... description \u00b6 Add documentation to the scalar: @gm . scalar ( description = \"ISO 8601 date string (YYYY-MM-DD)\" , serialize = lambda v : v . isoformat (), parse_value = lambda v : date . fromisoformat ( v ), ) @dataclass class Date : ... specified_by_url \u00b6 Reference a specification URL: @gm . scalar ( specified_by_url = \"https://tools.ietf.org/html/rfc3339\" , serialize = lambda v : v . isoformat (), parse_value = lambda v : datetime . fromisoformat ( v ), ) @dataclass class DateTime : ... Common Scalar Examples \u00b6 DateTime \u00b6 from datetime import datetime @gm . scalar ( name = \"DateTime\" , description = \"ISO 8601 datetime\" , serialize = lambda v : v . isoformat (), parse_value = lambda v : datetime . fromisoformat ( v ), ) @dataclass class DateTime : value : datetime def isoformat ( self ) -> str : return self . value . isoformat () JSON \u00b6 import json from typing import Any @gm . scalar ( name = \"JSON\" , description = \"Arbitrary JSON value\" , serialize = lambda v : v , # Pass through parse_value = lambda v : v , # Pass through ) @dataclass class JSON : value : Any UUID \u00b6 from uuid import UUID @gm . scalar ( name = \"UUID\" , description = \"UUID string\" , serialize = lambda v : str ( v . value ), parse_value = lambda v : UUIDScalar ( UUID ( v )), ) @dataclass class UUIDScalar : value : UUID Decimal \u00b6 from decimal import Decimal @gm . scalar ( name = \"Decimal\" , description = \"Arbitrary precision decimal\" , serialize = lambda v : str ( v . value ), parse_value = lambda v : DecimalScalar ( Decimal ( v )), ) @dataclass class DecimalScalar : value : Decimal Scalars as Input \u00b6 Custom scalars work in both input and output positions: @gm . type @dataclass class Mutation : @gm . field @staticmethod async def create_event ( parent , info , name : str , date : Date ) -> Event : # date is automatically parsed from input string return Event ( id = gm . ID ( \"1\" ), name = name , date = date ) mutation { createEvent ( name : \"Launch\" , date : \"2024-06-15\" ) { name date } } Error Handling \u00b6 If parse_value raises an exception, GraphQL returns a validation error: @gm . scalar ( serialize = lambda v : v . isoformat (), parse_value = lambda v : date . fromisoformat ( v ), # Raises ValueError for invalid dates ) @dataclass class Date : ... # Invalid date format returns an error mutation { createEvent ( date : \"not-a-date\" ) }","title":"Scalars"},{"location":"types/scalars/#custom-scalars","text":"Scalars are the leaf values in GraphQL. While GraphQL provides built-in scalars ( String , Int , Float , Boolean , ID ), you can define custom scalars for specialized data types.","title":"Custom Scalars"},{"location":"types/scalars/#built-in-scalars","text":"Grommet maps Python types to GraphQL scalars automatically: Python Type GraphQL Scalar str String int Int float Float bool Boolean gm.ID ID","title":"Built-in Scalars"},{"location":"types/scalars/#defining-custom-scalars","text":"Use the @gm.scalar decorator with serialize and parse_value functions: from dataclasses import dataclass from datetime import date import grommet as gm @gm . scalar ( serialize = lambda value : value . isoformat (), parse_value = lambda value : date . fromisoformat ( value ), ) @dataclass class Date : _value : date def __init__ ( self , value : date | str ): if isinstance ( value , str ): value = date . fromisoformat ( value ) object . __setattr__ ( self , \"_value\" , value ) def isoformat ( self ) -> str : return self . _value . isoformat () serialize - Converts Python value to JSON-compatible output parse_value - Converts JSON input to Python value","title":"Defining Custom Scalars"},{"location":"types/scalars/#using-custom-scalars","text":"Once defined, use scalars like any other type: @gm . type @dataclass class Event : id : gm . ID name : str date : Date @gm . type @dataclass class Query : @gm . field @staticmethod async def event ( parent , info , id : gm . ID ) -> Event : return Event ( id = id , name = \"Conference\" , date = Date ( date ( 2024 , 6 , 15 )), ) Query: { event ( id : \"1\" ) { name date # Returns \"2024-06-15\" } }","title":"Using Custom Scalars"},{"location":"types/scalars/#scalar-parameters","text":"","title":"Scalar Parameters"},{"location":"types/scalars/#name","text":"Override the GraphQL scalar name: @gm . scalar ( name = \"DateTime\" , serialize = lambda v : v . isoformat (), parse_value = lambda v : datetime . fromisoformat ( v ), ) @dataclass class MyDateTime : ...","title":"name"},{"location":"types/scalars/#description","text":"Add documentation to the scalar: @gm . scalar ( description = \"ISO 8601 date string (YYYY-MM-DD)\" , serialize = lambda v : v . isoformat (), parse_value = lambda v : date . fromisoformat ( v ), ) @dataclass class Date : ...","title":"description"},{"location":"types/scalars/#specified_by_url","text":"Reference a specification URL: @gm . scalar ( specified_by_url = \"https://tools.ietf.org/html/rfc3339\" , serialize = lambda v : v . isoformat (), parse_value = lambda v : datetime . fromisoformat ( v ), ) @dataclass class DateTime : ...","title":"specified_by_url"},{"location":"types/scalars/#common-scalar-examples","text":"","title":"Common Scalar Examples"},{"location":"types/scalars/#datetime","text":"from datetime import datetime @gm . scalar ( name = \"DateTime\" , description = \"ISO 8601 datetime\" , serialize = lambda v : v . isoformat (), parse_value = lambda v : datetime . fromisoformat ( v ), ) @dataclass class DateTime : value : datetime def isoformat ( self ) -> str : return self . value . isoformat ()","title":"DateTime"},{"location":"types/scalars/#json","text":"import json from typing import Any @gm . scalar ( name = \"JSON\" , description = \"Arbitrary JSON value\" , serialize = lambda v : v , # Pass through parse_value = lambda v : v , # Pass through ) @dataclass class JSON : value : Any","title":"JSON"},{"location":"types/scalars/#uuid","text":"from uuid import UUID @gm . scalar ( name = \"UUID\" , description = \"UUID string\" , serialize = lambda v : str ( v . value ), parse_value = lambda v : UUIDScalar ( UUID ( v )), ) @dataclass class UUIDScalar : value : UUID","title":"UUID"},{"location":"types/scalars/#decimal","text":"from decimal import Decimal @gm . scalar ( name = \"Decimal\" , description = \"Arbitrary precision decimal\" , serialize = lambda v : str ( v . value ), parse_value = lambda v : DecimalScalar ( Decimal ( v )), ) @dataclass class DecimalScalar : value : Decimal","title":"Decimal"},{"location":"types/scalars/#scalars-as-input","text":"Custom scalars work in both input and output positions: @gm . type @dataclass class Mutation : @gm . field @staticmethod async def create_event ( parent , info , name : str , date : Date ) -> Event : # date is automatically parsed from input string return Event ( id = gm . ID ( \"1\" ), name = name , date = date ) mutation { createEvent ( name : \"Launch\" , date : \"2024-06-15\" ) { name date } }","title":"Scalars as Input"},{"location":"types/scalars/#error-handling","text":"If parse_value raises an exception, GraphQL returns a validation error: @gm . scalar ( serialize = lambda v : v . isoformat (), parse_value = lambda v : date . fromisoformat ( v ), # Raises ValueError for invalid dates ) @dataclass class Date : ... # Invalid date format returns an error mutation { createEvent ( date : \"not-a-date\" ) }","title":"Error Handling"},{"location":"types/unions/","text":"Unions \u00b6 Unions represent a value that could be one of several object types. Unlike interfaces, union types don't share any fields. Defining Unions \u00b6 Use gm.union() to create a union type: from dataclasses import dataclass import grommet as gm @gm . type @dataclass class User : id : gm . ID name : str email : str @gm . type @dataclass class Organization : id : gm . ID name : str member_count : int # Create a union of User and Organization SearchResult = gm . union ( \"SearchResult\" , types = [ User , Organization ]) This generates: union SearchResult = User | Organization Using Unions \u00b6 Return union types from resolvers: @gm . type @dataclass class Query : @gm . field @staticmethod async def search ( parent , info , query : str ) -> list [ SearchResult ]: results : list [ User | Organization ] = [] # Search logic... if query . startswith ( \"@\" ): results . append ( User ( id = gm . ID ( \"1\" ), name = \"Alice\" , email = \"alice@example.com\" )) else : results . append ( Organization ( id = gm . ID ( \"2\" ), name = \"Acme Corp\" , member_count = 50 )) return results Querying Unions \u00b6 Use inline fragments to access type-specific fields: { search ( query : \"@alice\" ) { ... on User { id name email } ... on Organization { id name memberCount } } } Union Parameters \u00b6 name (required) \u00b6 The GraphQL type name: SearchResult = gm . union ( \"SearchResult\" , types = [ User , Organization ]) types (required) \u00b6 The possible types in the union: SearchResult = gm . union ( \"SearchResult\" , types = [ User , Organization , Post ], ) description \u00b6 Add documentation: SearchResult = gm . union ( \"SearchResult\" , types = [ User , Organization ], description = \"A search result can be either a user or an organization\" , ) Type Resolution \u00b6 Grommet automatically resolves the correct type based on the Python class of the returned object. Ensure your resolver returns instances of the union member types: @gm . field @staticmethod async def search ( parent , info , query : str ) -> list [ SearchResult ]: # Return actual User or Organization instances return [ User ( id = gm . ID ( \"1\" ), name = \"Alice\" , email = \"alice@example.com\" ), Organization ( id = gm . ID ( \"2\" ), name = \"Acme\" , member_count = 10 ), ] Union vs Interface \u00b6 Feature Union Interface Shared fields \u274c No \u2705 Yes Type annotation Function call Decorator Use case Unrelated types Related types with common fields When to use Unions \u00b6 Types have no common fields Types represent fundamentally different concepts You need to group unrelated types When to use Interfaces \u00b6 Types share common fields Types represent variations of the same concept You want to query common fields without fragments Nullable Unions \u00b6 Make union fields optional: @gm . type @dataclass class Query : @gm . field @staticmethod async def find ( parent , info , id : gm . ID ) -> SearchResult | None : # Return None if not found return None Lists of Unions \u00b6 @gm . type @dataclass class Query : @gm . field @staticmethod async def search ( parent , info ) -> list [ SearchResult ]: return [ User ( id = gm . ID ( \"1\" ), name = \"Alice\" , email = \"a@b.com\" ), Organization ( id = gm . ID ( \"2\" ), name = \"Acme\" , member_count = 10 ), ] Requirements \u00b6 Union member types must be: Decorated with @gm.type Object types (not inputs, interfaces, or other unions) # \u2705 Valid - both are @gm.type object types SearchResult = gm . union ( \"SearchResult\" , types = [ User , Organization ]) # \u274c Invalid - Input types cannot be in unions @gm . input @dataclass class UserInput : name : str InvalidUnion = gm . union ( \"Invalid\" , types = [ UserInput ]) # Raises error","title":"Unions"},{"location":"types/unions/#unions","text":"Unions represent a value that could be one of several object types. Unlike interfaces, union types don't share any fields.","title":"Unions"},{"location":"types/unions/#defining-unions","text":"Use gm.union() to create a union type: from dataclasses import dataclass import grommet as gm @gm . type @dataclass class User : id : gm . ID name : str email : str @gm . type @dataclass class Organization : id : gm . ID name : str member_count : int # Create a union of User and Organization SearchResult = gm . union ( \"SearchResult\" , types = [ User , Organization ]) This generates: union SearchResult = User | Organization","title":"Defining Unions"},{"location":"types/unions/#using-unions","text":"Return union types from resolvers: @gm . type @dataclass class Query : @gm . field @staticmethod async def search ( parent , info , query : str ) -> list [ SearchResult ]: results : list [ User | Organization ] = [] # Search logic... if query . startswith ( \"@\" ): results . append ( User ( id = gm . ID ( \"1\" ), name = \"Alice\" , email = \"alice@example.com\" )) else : results . append ( Organization ( id = gm . ID ( \"2\" ), name = \"Acme Corp\" , member_count = 50 )) return results","title":"Using Unions"},{"location":"types/unions/#querying-unions","text":"Use inline fragments to access type-specific fields: { search ( query : \"@alice\" ) { ... on User { id name email } ... on Organization { id name memberCount } } }","title":"Querying Unions"},{"location":"types/unions/#union-parameters","text":"","title":"Union Parameters"},{"location":"types/unions/#name-required","text":"The GraphQL type name: SearchResult = gm . union ( \"SearchResult\" , types = [ User , Organization ])","title":"name (required)"},{"location":"types/unions/#types-required","text":"The possible types in the union: SearchResult = gm . union ( \"SearchResult\" , types = [ User , Organization , Post ], )","title":"types (required)"},{"location":"types/unions/#description","text":"Add documentation: SearchResult = gm . union ( \"SearchResult\" , types = [ User , Organization ], description = \"A search result can be either a user or an organization\" , )","title":"description"},{"location":"types/unions/#type-resolution","text":"Grommet automatically resolves the correct type based on the Python class of the returned object. Ensure your resolver returns instances of the union member types: @gm . field @staticmethod async def search ( parent , info , query : str ) -> list [ SearchResult ]: # Return actual User or Organization instances return [ User ( id = gm . ID ( \"1\" ), name = \"Alice\" , email = \"alice@example.com\" ), Organization ( id = gm . ID ( \"2\" ), name = \"Acme\" , member_count = 10 ), ]","title":"Type Resolution"},{"location":"types/unions/#union-vs-interface","text":"Feature Union Interface Shared fields \u274c No \u2705 Yes Type annotation Function call Decorator Use case Unrelated types Related types with common fields","title":"Union vs Interface"},{"location":"types/unions/#when-to-use-unions","text":"Types have no common fields Types represent fundamentally different concepts You need to group unrelated types","title":"When to use Unions"},{"location":"types/unions/#when-to-use-interfaces","text":"Types share common fields Types represent variations of the same concept You want to query common fields without fragments","title":"When to use Interfaces"},{"location":"types/unions/#nullable-unions","text":"Make union fields optional: @gm . type @dataclass class Query : @gm . field @staticmethod async def find ( parent , info , id : gm . ID ) -> SearchResult | None : # Return None if not found return None","title":"Nullable Unions"},{"location":"types/unions/#lists-of-unions","text":"@gm . type @dataclass class Query : @gm . field @staticmethod async def search ( parent , info ) -> list [ SearchResult ]: return [ User ( id = gm . ID ( \"1\" ), name = \"Alice\" , email = \"a@b.com\" ), Organization ( id = gm . ID ( \"2\" ), name = \"Acme\" , member_count = 10 ), ]","title":"Lists of Unions"},{"location":"types/unions/#requirements","text":"Union member types must be: Decorated with @gm.type Object types (not inputs, interfaces, or other unions) # \u2705 Valid - both are @gm.type object types SearchResult = gm . union ( \"SearchResult\" , types = [ User , Organization ]) # \u274c Invalid - Input types cannot be in unions @gm . input @dataclass class UserInput : name : str InvalidUnion = gm . union ( \"Invalid\" , types = [ UserInput ]) # Raises error","title":"Requirements"}]}